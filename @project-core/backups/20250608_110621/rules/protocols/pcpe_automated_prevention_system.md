---
description: P.C.P.E. Automated Prevention System - Sistema de Alertas Preventivos em Tempo Real
author: GRUPO US VIBECODE SYSTEM V2.0
version: 1.0
priority: HIGH
globs: ["**/*"]
tags: ["prevention", "alerts", "real-time", "automation"]
alwaysApply: true
integrates: ["protocols/proactive_error_correction_protocol.md", "protocols/pcpe_ml_predictive_engine.md"]
---

# üö® P.C.P.E. AUTOMATED PREVENTION SYSTEM

## üìã OVERVIEW

Sistema de **Preven√ß√£o Automatizada** que utiliza alertas em tempo real, an√°lise de contexto e sugest√µes proativas para **prevenir erros antes que ocorram**, integrando-se com o ML Engine para m√°xima efic√°cia preventiva.

## üéØ OBJETIVOS DO PREVENTION SYSTEM

### **Preven√ß√£o Proativa:**
- **Detectar situa√ß√µes de risco** antes da execu√ß√£o
- **Alertar em tempo real** sobre potenciais problemas
- **Sugerir a√ß√µes preventivas** espec√≠ficas
- **Bloquear execu√ß√µes perigosas** quando necess√°rio

### **Intelig√™ncia Contextual:**
- **Analisar contexto atual** do desenvolvimento
- **Comparar com padr√µes hist√≥ricos** de erro
- **Adaptar alertas** ao n√≠vel de experi√™ncia do usu√°rio
- **Personalizar preven√ß√£o** por projeto/framework

## üõ°Ô∏è ARQUITETURA DO PREVENTION SYSTEM

### **Componentes Principais:**

```javascript
const PreventionSystem = {
  // Monitor de Contexto em Tempo Real
  ContextMonitor: {
    monitorFileChanges: () => {},
    trackCommandHistory: () => {},
    analyzeProjectState: () => {},
    detectRiskPatterns: () => {}
  },
  
  // Sistema de Alertas
  AlertSystem: {
    generateAlert: () => {},
    prioritizeAlerts: () => {},
    displayAlert: () => {},
    trackAlertEffectiveness: () => {}
  },
  
  // Engine de Sugest√µes
  SuggestionEngine: {
    generatePreventiveSuggestions: () => {},
    rankSuggestions: () => {},
    customizeSuggestions: () => {},
    trackSuggestionSuccess: () => {}
  },
  
  // Sistema de Bloqueio
  SafetyBlocker: {
    assessExecutionSafety: () => {},
    blockDangerousOperations: () => {},
    requireConfirmation: () => {},
    logBlockedOperations: () => {}
  }
};
```

## üîç SISTEMA DE MONITORAMENTO CONTEXTUAL

### **1. Real-Time Context Monitor**

```javascript
class RealTimeContextMonitor {
  constructor() {
    this.contextHistory = [];
    this.riskIndicators = new Set();
    this.activeMonitors = new Map();
  }

  startMonitoring() {
    // Monitor de mudan√ßas de arquivo
    this.startFileMonitor();
    
    // Monitor de comandos
    this.startCommandMonitor();
    
    // Monitor de estado do projeto
    this.startProjectStateMonitor();
    
    // Monitor de ambiente
    this.startEnvironmentMonitor();
  }

  startFileMonitor() {
    const fileWatcher = {
      onFileChange: (filePath, changeType) => {
        const riskAssessment = this.assessFileChangeRisk(filePath, changeType);
        
        if (riskAssessment.level >= 'MEDIUM') {
          this.triggerPreventiveAlert({
            type: 'FILE_CHANGE_RISK',
            level: riskAssessment.level,
            file: filePath,
            change: changeType,
            risks: riskAssessment.risks,
            suggestions: riskAssessment.suggestions
          });
        }
      }
    };
    
    this.activeMonitors.set('fileWatcher', fileWatcher);
  }

  assessFileChangeRisk(filePath, changeType) {
    const riskFactors = {
      // Arquivos cr√≠ticos
      criticalFiles: [
        'package.json',
        'tsconfig.json',
        'next.config.js',
        'vite.config.ts',
        'prisma/schema.prisma',
        '.env'
      ],
      
      // Tipos de mudan√ßa arriscados
      riskyChanges: [
        'dependency-modification',
        'config-change',
        'schema-alteration',
        'environment-variable-change'
      ]
    };

    let riskLevel = 'LOW';
    const risks = [];
    const suggestions = [];

    // Verificar se √© arquivo cr√≠tico
    if (riskFactors.criticalFiles.some(critical => filePath.includes(critical))) {
      riskLevel = 'HIGH';
      risks.push('Modifica√ß√£o em arquivo cr√≠tico do projeto');
      
      if (filePath.includes('package.json')) {
        suggestions.push('Verificar compatibilidade de depend√™ncias antes de instalar');
        suggestions.push('Fazer backup do package-lock.json');
      }
      
      if (filePath.includes('tsconfig.json')) {
        suggestions.push('Verificar se mudan√ßas n√£o quebram tipos existentes');
        suggestions.push('Executar type-check ap√≥s modifica√ß√£o');
      }
      
      if (filePath.includes('prisma/schema.prisma')) {
        suggestions.push('Gerar migration antes de aplicar mudan√ßas');
        suggestions.push('Verificar impacto em dados existentes');
      }
    }

    return { level: riskLevel, risks, suggestions };
  }

  startCommandMonitor() {
    const commandMonitor = {
      onCommandExecution: (command, context) => {
        const riskAssessment = this.assessCommandRisk(command, context);
        
        if (riskAssessment.shouldBlock) {
          return this.blockCommand(command, riskAssessment);
        }
        
        if (riskAssessment.level >= 'MEDIUM') {
          this.triggerPreventiveAlert({
            type: 'COMMAND_RISK',
            level: riskAssessment.level,
            command: command,
            risks: riskAssessment.risks,
            suggestions: riskAssessment.suggestions
          });
        }
      }
    };
    
    this.activeMonitors.set('commandMonitor', commandMonitor);
  }

  assessCommandRisk(command, context) {
    const dangerousCommands = {
      // Comandos de alto risco
      'rm -rf': { level: 'CRITICAL', shouldBlock: true },
      'sudo rm': { level: 'CRITICAL', shouldBlock: true },
      'npm install --force': { level: 'HIGH', shouldBlock: false },
      'yarn install --force': { level: 'HIGH', shouldBlock: false },
      'prisma db push --force-reset': { level: 'CRITICAL', shouldBlock: true },
      'git reset --hard': { level: 'HIGH', shouldBlock: false },
      'git push --force': { level: 'HIGH', shouldBlock: false }
    };

    const risks = [];
    const suggestions = [];
    let level = 'LOW';
    let shouldBlock = false;

    // Verificar comandos perigosos
    Object.keys(dangerousCommands).forEach(dangerous => {
      if (command.includes(dangerous)) {
        const commandRisk = dangerousCommands[dangerous];
        level = commandRisk.level;
        shouldBlock = commandRisk.shouldBlock;
        
        risks.push(`Comando perigoso detectado: ${dangerous}`);
        
        if (dangerous.includes('rm')) {
          suggestions.push('Verificar caminhos antes de deletar');
          suggestions.push('Considerar usar lixeira ao inv√©s de rm');
        }
        
        if (dangerous.includes('--force')) {
          suggestions.push('Tentar comando sem --force primeiro');
          suggestions.push('Verificar se for√ßa √© realmente necess√°ria');
        }
        
        if (dangerous.includes('prisma')) {
          suggestions.push('Fazer backup do banco antes de reset');
          suggestions.push('Verificar se dados podem ser perdidos');
        }
      }
    });

    return { level, shouldBlock, risks, suggestions };
  }
}
```

### **2. Alert Generation System**

```javascript
class AlertGenerationSystem {
  constructor() {
    this.alertQueue = [];
    this.alertHistory = [];
    this.userPreferences = {
      alertLevel: 'MEDIUM', // MINIMAL, LOW, MEDIUM, HIGH, CRITICAL
      alertStyle: 'DETAILED', // MINIMAL, SUMMARY, DETAILED
      autoBlock: false
    };
  }

  generateAlert(alertData) {
    const alert = {
      id: this.generateAlertId(),
      timestamp: new Date().toISOString(),
      type: alertData.type,
      level: alertData.level,
      title: this.generateAlertTitle(alertData),
      message: this.generateAlertMessage(alertData),
      suggestions: alertData.suggestions || [],
      actions: this.generateAlertActions(alertData),
      context: alertData.context || {}
    };

    // Verificar se deve mostrar baseado nas prefer√™ncias
    if (this.shouldShowAlert(alert)) {
      this.displayAlert(alert);
    }

    // Sempre registrar no hist√≥rico
    this.alertHistory.push(alert);
    
    return alert;
  }

  generateAlertTitle(alertData) {
    const titles = {
      'FILE_CHANGE_RISK': 'üìÅ Modifica√ß√£o em Arquivo Cr√≠tico Detectada',
      'COMMAND_RISK': '‚ö†Ô∏è Comando de Alto Risco Detectado',
      'DEPENDENCY_RISK': 'üì¶ Risco de Depend√™ncia Identificado',
      'BUILD_RISK': 'üî® Risco de Build Detectado',
      'DATABASE_RISK': 'üóÑÔ∏è Opera√ß√£o de Banco Perigosa',
      'ENVIRONMENT_RISK': 'üåç Mudan√ßa de Ambiente Arriscada'
    };

    return titles[alertData.type] || '‚ö†Ô∏è Risco Detectado';
  }

  generateAlertMessage(alertData) {
    let message = `üö® PREVENTION SYSTEM ALERT - N√≠vel: ${alertData.level}\n\n`;
    
    if (alertData.risks && alertData.risks.length > 0) {
      message += 'üéØ Riscos Identificados:\n';
      alertData.risks.forEach(risk => {
        message += `   ‚Ä¢ ${risk}\n`;
      });
      message += '\n';
    }

    if (alertData.suggestions && alertData.suggestions.length > 0) {
      message += 'üí° Sugest√µes Preventivas:\n';
      alertData.suggestions.forEach(suggestion => {
        message += `   ‚úÖ ${suggestion}\n`;
      });
      message += '\n';
    }

    message += 'ü§î Deseja prosseguir mesmo assim?';
    
    return message;
  }

  generateAlertActions(alertData) {
    const baseActions = [
      { id: 'proceed', label: 'Prosseguir', style: 'warning' },
      { id: 'cancel', label: 'Cancelar', style: 'safe' },
      { id: 'more_info', label: 'Mais Informa√ß√µes', style: 'info' }
    ];

    // Adicionar a√ß√µes espec√≠ficas baseadas no tipo
    if (alertData.type === 'COMMAND_RISK') {
      baseActions.unshift({
        id: 'modify_command',
        label: 'Modificar Comando',
        style: 'primary'
      });
    }

    if (alertData.type === 'FILE_CHANGE_RISK') {
      baseActions.unshift({
        id: 'backup_first',
        label: 'Fazer Backup Primeiro',
        style: 'primary'
      });
    }

    return baseActions;
  }

  displayAlert(alert) {
    console.log('\n' + '='.repeat(60));
    console.log(`üö® ${alert.title}`);
    console.log('='.repeat(60));
    console.log(alert.message);
    
    if (alert.actions && alert.actions.length > 0) {
      console.log('\nüìã A√ß√µes Dispon√≠veis:');
      alert.actions.forEach((action, index) => {
        const emoji = this.getActionEmoji(action.style);
        console.log(`   ${index + 1}. ${emoji} ${action.label}`);
      });
    }
    
    console.log('\n' + '='.repeat(60));
  }

  getActionEmoji(style) {
    const emojis = {
      'safe': '‚úÖ',
      'warning': '‚ö†Ô∏è',
      'primary': 'üîß',
      'info': '‚ÑπÔ∏è',
      'danger': 'üö´'
    };
    
    return emojis[style] || 'üìã';
  }
}
```

### **3. Suggestion Engine**

```javascript
class PreventiveSuggestionEngine {
  constructor() {
    this.suggestionDatabase = new Map();
    this.contextualSuggestions = new Map();
    this.userFeedback = [];
  }

  generateSuggestions(context, riskAssessment) {
    const suggestions = [];

    // Sugest√µes baseadas no tipo de risco
    const typeSuggestions = this.getTypeSuggestions(context.type, riskAssessment);
    suggestions.push(...typeSuggestions);

    // Sugest√µes baseadas no contexto
    const contextSuggestions = this.getContextualSuggestions(context);
    suggestions.push(...contextSuggestions);

    // Sugest√µes baseadas no hist√≥rico
    const historicalSuggestions = this.getHistoricalSuggestions(context);
    suggestions.push(...historicalSuggestions);

    // Ranquear e filtrar sugest√µes
    return this.rankAndFilterSuggestions(suggestions, context);
  }

  getTypeSuggestions(type, riskAssessment) {
    const typeSuggestions = {
      'DEPENDENCY_RISK': [
        {
          id: 'check_compatibility',
          text: 'Verificar compatibilidade de vers√µes antes de instalar',
          priority: 'HIGH',
          action: 'npm ls --depth=0'
        },
        {
          id: 'backup_lockfile',
          text: 'Fazer backup do package-lock.json',
          priority: 'MEDIUM',
          action: 'cp package-lock.json package-lock.json.backup'
        },
        {
          id: 'use_exact_versions',
          text: 'Considerar usar vers√µes exatas ao inv√©s de ranges',
          priority: 'LOW',
          action: 'npm install --save-exact'
        }
      ],
      
      'BUILD_RISK': [
        {
          id: 'clean_build',
          text: 'Limpar cache de build antes de tentar novamente',
          priority: 'HIGH',
          action: 'npm run clean && npm run build'
        },
        {
          id: 'check_types',
          text: 'Verificar erros de TypeScript primeiro',
          priority: 'HIGH',
          action: 'npx tsc --noEmit'
        },
        {
          id: 'update_dependencies',
          text: 'Verificar se depend√™ncias est√£o atualizadas',
          priority: 'MEDIUM',
          action: 'npm outdated'
        }
      ],
      
      'DATABASE_RISK': [
        {
          id: 'backup_database',
          text: 'CR√çTICO: Fazer backup do banco antes de prosseguir',
          priority: 'CRITICAL',
          action: 'pg_dump database_name > backup.sql'
        },
        {
          id: 'test_migration',
          text: 'Testar migration em ambiente de desenvolvimento primeiro',
          priority: 'HIGH',
          action: 'npx prisma migrate dev'
        },
        {
          id: 'check_data_impact',
          text: 'Verificar impacto nos dados existentes',
          priority: 'HIGH',
          action: 'npx prisma migrate diff'
        }
      ]
    };

    return typeSuggestions[type] || [];
  }

  getContextualSuggestions(context) {
    const suggestions = [];

    // Sugest√µes baseadas no framework
    if (context.framework === 'next.js') {
      suggestions.push({
        id: 'nextjs_build_check',
        text: 'Verificar se build do Next.js est√° funcionando',
        priority: 'MEDIUM',
        action: 'npm run build'
      });
    }

    if (context.framework === 'vite') {
      suggestions.push({
        id: 'vite_config_check',
        text: 'Verificar configura√ß√£o do Vite',
        priority: 'MEDIUM',
        action: 'npx vite --config vite.config.ts'
      });
    }

    // Sugest√µes baseadas no projeto
    if (context.project === 'neonpro') {
      suggestions.push({
        id: 'neonpro_health_check',
        text: 'Executar health check espec√≠fico do NEONPRO',
        priority: 'MEDIUM',
        action: 'npm run test:health'
      });
    }

    return suggestions;
  }

  rankAndFilterSuggestions(suggestions, context) {
    // Remover duplicatas
    const uniqueSuggestions = suggestions.filter((suggestion, index, self) =>
      index === self.findIndex(s => s.id === suggestion.id)
    );

    // Ordenar por prioridade
    const priorityOrder = { 'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1 };
    uniqueSuggestions.sort((a, b) => 
      priorityOrder[b.priority] - priorityOrder[a.priority]
    );

    // Limitar n√∫mero de sugest√µes
    return uniqueSuggestions.slice(0, 5);
  }
}
```

## üîí SISTEMA DE BLOQUEIO DE SEGURAN√áA

### **Safety Blocker Implementation:**

```javascript
class SafetyBlocker {
  constructor() {
    this.blockedOperations = [];
    this.blockingRules = new Map();
    this.emergencyOverrides = new Set();
  }

  assessExecutionSafety(command, context) {
    const safetyAssessment = {
      shouldBlock: false,
      blockReason: '',
      severity: 'LOW',
      overrideRequired: false,
      alternatives: []
    };

    // Verificar comandos cr√≠ticos
    if (this.isCriticalCommand(command)) {
      safetyAssessment.shouldBlock = true;
      safetyAssessment.blockReason = 'Comando cr√≠tico detectado';
      safetyAssessment.severity = 'CRITICAL';
      safetyAssessment.overrideRequired = true;
    }

    // Verificar contexto perigoso
    if (this.isDangerousContext(context)) {
      safetyAssessment.shouldBlock = true;
      safetyAssessment.blockReason = 'Contexto perigoso detectado';
      safetyAssessment.severity = 'HIGH';
    }

    return safetyAssessment;
  }

  isCriticalCommand(command) {
    const criticalPatterns = [
      /rm\s+-rf\s+\//, // rm -rf /
      /sudo\s+rm/, // sudo rm
      /DROP\s+DATABASE/i, // SQL DROP DATABASE
      /TRUNCATE\s+TABLE/i, // SQL TRUNCATE
      /git\s+push\s+--force-with-lease\s+origin\s+main/, // Force push to main
      /prisma\s+db\s+push\s+--force-reset/ // Prisma force reset
    ];

    return criticalPatterns.some(pattern => pattern.test(command));
  }

  blockCommand(command, assessment) {
    const blockEntry = {
      timestamp: new Date().toISOString(),
      command: command,
      reason: assessment.blockReason,
      severity: assessment.severity,
      context: assessment.context
    };

    this.blockedOperations.push(blockEntry);

    console.log('\nüö´ OPERA√á√ÉO BLOQUEADA PELO SISTEMA DE SEGURAN√áA');
    console.log('=' .repeat(50));
    console.log(`‚ö†Ô∏è Comando: ${command}`);
    console.log(`üéØ Motivo: ${assessment.blockReason}`);
    console.log(`üìä Severidade: ${assessment.severity}`);
    
    if (assessment.alternatives && assessment.alternatives.length > 0) {
      console.log('\nüí° Alternativas Sugeridas:');
      assessment.alternatives.forEach(alt => {
        console.log(`   ‚úÖ ${alt}`);
      });
    }

    if (assessment.overrideRequired) {
      console.log('\nüîì Para prosseguir, use: EXECUTE WITH MANUAL SUPERVISION');
    }

    console.log('=' .repeat(50));

    return { blocked: true, entry: blockEntry };
  }
}
```

---

**üö® GRUPO US VIBECODE SYSTEM V2.0 - P.C.P.E. AUTOMATED PREVENTION**  
**Sistema de Alertas Preventivos e Bloqueio de Seguran√ßa**
